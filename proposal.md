This proposal discusses about an idea for the webhook channel and would bring some changes to other related elements (eg: web_messages and event collector).

## Channel Webhook

This channel would allow a user to send a request to the bot via an API call, and the responses would be sent back to a configured endpoint. There could be one different endpoint per bot, and the payload would include a signature to ensure that it came from Botpress.

To ensure messages are sent in order and that none are lost, every message passing through the outgoing middleware will be persisted to the database. Then, at regular intervals, it will pick a batch of messages, and send them to the webhook endpoint. If the response code was 200, then it will mark those messages as "sent" in the db (along with the date).

I suggest storing only the Event ID in that table (fields: `eventId, sent, sentOn, createdDate`) to keep overhead at a minimum.

We already store incoming events and outgoing events with the event collector, so we could read the events from that table when we need to send them to the webhook endpoint.

### Incoming event

Actually, we only send back to the user the `outgoing` events (those containing the payload of the response of the bot). In this case, it may be useful to access the incoming event after it was processed so the state, nlu, suggestions and decision can be analyzed.

When the event is generated by the API, we could add the generated ID to the `webhook_events` table, so it can also be sent to the webhook endpoint along with the outgoing events. It would be still marked as "direction = incoming" so it would be easy to differentiate them from the backend.

### Multi-nodes

Since all nodes have access to the same database, we need a locking mechanism to prevent all nodes from trying to process those requests all at once. I suggest adding the method `bp.distributed.isLockAcquired(lockName: string)` to the SDK. As long as it returns `true`, it means that the current node is the only node that will process the block of code. It will allow other nodes to take over if one goes down.

### Configuration

Those are the possible configuration options I can think of:

- enabled: If the channel is enabled or not for that specific bot
- signToken: The token used to sign the payload. The signature will be included as an header (X-BP-SIGNATURE)
- webhookEndpoint: The URL called to process events
- batchSize: If we batch events sent to the endpoint or if they are sent manually. 0 = individual, 20 = default ?? (unsure - do we always batch them, is it configurable?)
- interval: The interval of the task which checks if there are events to send to the endpoint
- retryDelay: When the endpoint returns a code different than 200, it's the time before it will try again to send events

## Event Collector

Actually, the event collector stores the following fields: `id, botId, channel, threadId, target, sessionId, direction, incomingEventId, event, createdOn`. The id is an auto-increment instead of being the real event ID, so I suggest we either change the field type (numeric - string) or add an `eventId` field. The event contains the entire event (so some of those fields are duplicated).

We could optimize that table so it can be used by channel web, webhook, and other modules by extracting the fields from the json `event` and adding multiple columns. That way, information will not be saved twice.

It would result in the table `events` to have those fields: `id, eventId, botId, channel, threadId, target, sessionId, direction, type, preview, incomingEventId, payload, metadata, createdOn`. Metadata would contain all the other fields of the event (eg: state, nlu, etc). When consuming the event, we simply have to rebuild the event payload from those fields.

Benefits:

- One location to store events for all channels
- One source of truth containing 100% of incoming and outgoing events
- We can get rid of the table web_messages (no longer required)
- Modules can refer to an eventId instead of storing the complete event (eg for sending to webhook endpoint)

Disadvantage:

- Events are batched, so there may be a small delay until they are available in the events table
